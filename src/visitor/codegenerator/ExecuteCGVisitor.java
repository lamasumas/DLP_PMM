package visitor.codegenerator;

import ast.Program;
import ast.definitions.FunctionDefinition;
import ast.definitions.VarDefinition;
import ast.expressions.FunctionInvocation;
import ast.statements.*;
import ast.types.FuncType;
import ast.types.VoidType;

public class ExecuteCGVisitor extends AbstractCGVisitor <Void,  FunctionDefinition>  {

   private CodeGenerator cg;
   private AddressCGVisitor addressCGVisitor;
   private ValueCGVisitor valueCGVisitor;

    public void setCodeGenerator( CodeGenerator cg){
        this.cg = cg;
    }

    public void setAddressCGVisitor(AddressCGVisitor addressCGVisitor){
        this.addressCGVisitor = addressCGVisitor;
    }

    public void setValueCGVisitor(ValueCGVisitor valueCGVisitor){
        this.valueCGVisitor = valueCGVisitor;
    }

    @Override
    public Void visit(FunctionDefinition a, FunctionDefinition param) {
        /**
         *  execute[[FunctionDefinition: functionDefinition -> varDefinition* statement*]] () =
         *      for (VarDefinition variable: functionDefinition.getType().getParams())
         *          execute[[variable]]()
         *      for(VarDefinition variable: varDefinition*)
         *          execute[[variable]]()
         *      '* the sum of all the bytes of the local variables
         *      <enter> varDefinition*.getType.getByteSize()
         *      for(Statement aStatement: statement*)
         *          execute[[anStatement]]()
         *
         *  '* As i didn't know if we have to implement the return in lab11, i created the next part
         *  my self so the output.txt is the same
         *
         *       if( a.getType.getReturnType().getByteSize() == 0) {
         *
         *       '* it enter here only if the return type is void.
         *       '* So we can suppose that the function doesn't have
         *       '* any return statement, so we generated by hand
         *
         *          int totalByteSize = varDefinition*.getType.getByteSize()
         *          int parameterSize = functionçDefinition.getType()).getParams().size() == 0? 0:
         *                 (functionçDefinition.getParams().get(0).getOffset();
         *
         *           <ret> 0, totalByteSize, parameterSize
         */
        cg.addLine(a.getLine());
        cg.id(a.getName());
        cg.writeComment("Parameters");
        ((FuncType)a.getType()).getParams().forEach( varDefinition -> varDefinition.accept(this,param));
        cg.writeComment("Local variables");
        a.getDefinitionList().forEach( defintion -> defintion.accept( this, param));
        int totalByteSize = a.getDefinitionList().size() == 0? 0: -a.getDefinitionList().get(a.getDefinitionList().size()-1).getOffset();
        cg.enter(totalByteSize);

        a.getStatementList().forEach(statement ->  statement.accept(this, a));

        if(((FuncType) a.getType()).getReturnType().getByteSize()==0){
            int parameterSize = ((FuncType)a.getType()).getParams().size() == 0? 0:
                    ((FuncType)a.getType()).getParams().stream()
                            .mapToInt(varDefinition -> varDefinition.getType().getByteSize()).sum();
            cg.addReturn(0,totalByteSize, parameterSize);

        }
        cg.addEmptyLine();
        return null;
    }

    @Override
    public Void visit(VarDefinition a, FunctionDefinition param) {
        /**
         * It doesn't have a template, this is only for adding comments,
         *  execute[[VarDefinition: varDefinition -> type]] () =
         */
        cg.writeComment(a.getType().getTypeString() + " " + a.getName() +
                "( offset " + a.getOffset() + " )");
        if(a.isHasValue()){
            a.accept(addressCGVisitor, param);
            a.getValue().accept(valueCGVisitor, param);
            cg.store(a.getType().getSuffix());
        }


        return null;
    }

    @Override
    public Void visit(Assignment a, FunctionDefinition param) {
        /**
         * execute[[Assignment: statement -> exp1 exp1]] () =
         *  address[[exp1]]
         *  value[[exp2]]
         *  <store exp1.type.getSuffix()>
         */
        cg.addLine(a.getLine());
        cg.writeComment("Assignment");
        a.getLeftExpression().accept(addressCGVisitor, param );
        a.getRightExpression().accept(valueCGVisitor, param);
        cg.store(a.getLeftExpression().getType().getSuffix());
        cg.addEmptyLine();

        return null;
    }

    @Override
    public Void visit(IfElse a, FunctionDefinition param) {
        /**
         *  execute[[ IfElse: stm -> exp stm1* stm2* ]] () =
         *      int else = cg.getLabel();
         *      int end = cg.getLabel();
         *      value[[exp]]()
         *      <jz label> else
         *      for( Statement statement: stm1*)
         *          execute[[statement]]()
         *      <jmp label> end
         *      <label> else <:>
         *      for( Statement statement: stm2* )
         *          execute[[statement]]()
         *      <label> end <:>
         */
        cg.addLine(a.getLine());
        cg.writeComment("If/Else block");
        cg.addLine(a.getLine());
        int elseLabel = cg.getLabel();
        int endLabel = cg.getLabel();
        a.getTheExpression().accept(valueCGVisitor, null);
        cg.jumpZ(elseLabel);
        cg.writeComment("Inside If body:");
        a.getIfStatements().forEach(stat -> stat.accept( this, param));
        cg.jump(endLabel);
        cg.addLabel(elseLabel);
        cg.writeComment("Inside Else body:");
        a.getElseStatements().forEach(stat -> stat.accept(this, param));
        cg.addLabel(endLabel);
        cg.addEmptyLine();
        return null;
    }

    @Override
    public Void visit(Input a, FunctionDefinition param) {
        /**
         * execute[[ Input: statement -> expression]] () =
         *      address[[expression]]()
         *      <in> expression.type.suffix()
         *      <store expression.getType().getSuffix()
         */
        cg.addLine(a.getLine());
        cg.writeComment("Read");
        a.getExpressionList().forEach(expression -> {
            expression.accept(addressCGVisitor, param);
            cg.in(expression.getType().getSuffix());
            cg.store(expression.getType().getSuffix());
        });
        cg.addEmptyLine();
        return null;
    }

    @Override
    public Void visit(Print a, FunctionDefinition param) {
        /**
         * execute[[ Print: statement -> expression*]] () =
         *      value[[expression]]()
         *      <out> expression.type.suffix()
         */
        a.getExpressionList().forEach(expression ->  {
            cg.addLine(expression.getLine());
            cg.writeComment("Write");
            expression.accept(valueCGVisitor, param);
            cg.out(expression.getType().getSuffix());
        });
        cg.addEmptyLine();
        return null;
    }

    @Override
    public Void visit(Return a, FunctionDefinition param) {
        /**
         *  execute[[Return: stm -> exp]] () =
         *  value[[exp]] ()
         *  <ret> exp.getType().getByteSize() , localVariableSize, parameterSize
         */
        cg.addLine(a.getLine());
        cg.writeComment("Return");
        a.getTheExpression().accept(valueCGVisitor, param);
        int totalByteSize = -param.getDefinitionList().get(param.getDefinitionList().size()-1).getOffset();
        int parameterSize = ((FuncType)param.getType()).getParams().size() == 0? 0:
                ((FuncType)param.getType()).getParams().stream()
                        .mapToInt(varDefinition -> varDefinition.getType().getByteSize()).sum();

        cg.addReturn(((FuncType) param.getType()).getReturnType().getByteSize(), totalByteSize, parameterSize );
        cg.addEmptyLine();
        return null;
    }

    @Override
    public Void visit(While a, FunctionDefinition param) {
        /**
         *  execute[[WhileStatement: stmt -> exp stmt1*]] () =
         *      int condition = cg.getLabel();
         *      int end = cg.getLabel();
         *      <label> condition <:>
         *      value[[exp]]()
         *      <jz label> end
         *      for( Statment statement: stmt1*)
         *          execute[[statement]]()
         *      <jmp label> condition
         *      <label> end <:>
         */
        cg.addLine(a.getLine());
        cg.writeComment("While");
        int condition = cg.getLabel();
        int end = cg.getLabel();
        cg.writeComment("Condition:");
        cg.addLabel(condition);
        a.getTheExpression().accept(valueCGVisitor, null);
        cg.jumpZ(end);
        cg.writeComment("While body:");
        a.getTheStatemList().forEach( stmt -> stmt.accept(this, param));
        cg.jump(condition);
        cg.addLabel(end);
        cg.addEmptyLine();
        return null;
    }

    @Override
    public Void visit(Program a, FunctionDefinition param) {
        /**
         *  execute[[ Program: program -> definition*]] () =
         *      for(Definition definition : definition*)
         *          if( definition instanceof VarDefinition)
         *              execute[[definition]]()
         *      <call main>
         *      <halt>
         *      for( Definition definition : definition*)
         *          if (definition instanceof FunDefinition)
         *              execute[[definition]]()
          */
        cg.writeComment("Global variables");
        a.getDefinitionList().forEach( definition -> {
            if(definition instanceof  VarDefinition) {
                definition.accept(this, param);
            }
        });
        cg.call("main");
        cg.halt();
        a.getDefinitionList().forEach(definition -> {
            if(definition instanceof FunctionDefinition)
                definition.accept(this, param);
        });
        cg.addEmptyLine();
        return null;
    }

    @Override
    public Void visit(FunctionInvocation a, FunctionDefinition param) {
        /**
         *  execute[[FunctionInvoncation: stat -> exp exp1*]]
         *      value[[(Expression) stat]]()
         *      if(!((Expression)stat).type instanceof VoidType)
         *          <pop>((Expression)stat).type.getSuffix()
         */
        cg.addLine(a.getLine());
        a.accept(valueCGVisitor, null);
        if( !(a.getType()  instanceof VoidType))
            cg.pop(a.getType().getSuffix());
        cg.addEmptyLine();
        return null;
    }
}